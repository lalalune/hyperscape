// Test World: Terrain Generation
// This test world specifically tests the terrain generation system
// with visual color proxies for verification

app.configure([
  {
    key: 'testSeed',
    type: 'number',
    label: 'Test Seed',
    initial: 12345,
    min: 1,
    max: 999999,
    hint: 'Seed for deterministic terrain generation'
  },
  {
    key: 'showVisualProxies',
    type: 'toggle',
    label: 'Show Visual Proxies',
    initial: true,
    hint: 'Show colored cubes for visual testing'
  }
])

// Inline ProceduralTerrain class for testing
// This is a simplified version that focuses on the core functionality

// Simplified terrain generation class
class SimpleTerrain {
  constructor(config) {
    this.seed = config.seed || 12345
    this.worldSize = config.worldSize || 200
    this.chunkSize = config.chunkSize || 50
    this.maxHeight = config.maxHeight || 25
    this.waterLevel = config.waterLevel || 0
    this.chunks = new Map()
    this.biomes = this.generateBiomes()
    
    // Simple RNG
    this.rng = this.createRNG(this.seed)
  }
  
  createRNG(seed) {
    return function(min = 0, max = 1) {
      seed = (seed * 9301 + 49297) % 233280
      return min + (seed / 233280) * (max - min)
    }
  }
  
  generateBiomes() {
    const biomeTypes = [
      { id: 'grass', name: 'Grassland', color: 0x4a7c59, height: 0.3 },
      { id: 'dirt', name: 'Badlands', color: 0x8b4513, height: 0.2 },
      { id: 'stone', name: 'Mountains', color: 0x808080, height: 0.8 },
      { id: 'water', name: 'Lakes', color: 0x4682b4, height: -0.1 }
    ]
    
    const biomes = []
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * Math.PI * 2
      const distance = this.worldSize * 0.3
      biomes.push({
        x: Math.cos(angle) * distance,
        z: Math.sin(angle) * distance,
        biome: biomeTypes[i]
      })
    }
    return biomes
  }
  
  getBiomeAt(x, z) {
    let closest = this.biomes[0]
    let minDist = Infinity
    
    for (const biome of this.biomes) {
      const dx = x - biome.x
      const dz = z - biome.z
      const dist = Math.sqrt(dx * dx + dz * dz)
      if (dist < minDist) {
        minDist = dist
        closest = biome
      }
    }
    
    return closest.biome
  }
  
  getHeightAt(x, z) {
    const biome = this.getBiomeAt(x, z)
    const noise = this.noise(x * 0.02, z * 0.02)
    return biome.height * this.maxHeight + noise * 5
  }
  
  getTypeAt(x, z) {
    return this.getBiomeAt(x, z).id
  }
  
  isWalkable(x, z) {
    const biome = this.getBiomeAt(x, z)
    return biome.id !== 'water'
  }
  
  noise(x, z) {
    const intX = Math.floor(x)
    const intZ = Math.floor(z)
    const fracX = x - intX
    const fracZ = z - intZ
    
    // Create deterministic noise values based on coordinates
    const a = this.hash(intX, intZ)
    const b = this.hash(intX + 1, intZ)
    const c = this.hash(intX, intZ + 1)
    const d = this.hash(intX + 1, intZ + 1)
    
    const i1 = a * (1 - fracX) + b * fracX
    const i2 = c * (1 - fracX) + d * fracX
    
    return i1 * (1 - fracZ) + i2 * fracZ
  }
  
  hash(x, z) {
    // Simple hash function that generates consistent values based on coordinates
    let hash = this.seed
    hash = ((hash << 5) + hash) + x
    hash = ((hash << 5) + hash) + z
    hash = hash & hash // Convert to 32bit integer
    hash = Math.abs(hash)
    return (hash % 1000) / 1000 // Normalize to 0-1
  }
  
  getBiomePoints() {
    return this.biomes
  }
  
  async init() {
    console.log('[SimpleTerrain] Terrain system initialized')
    return true
  }
  
  generateChunk(x, z) {
    const chunk = {
      x, z,
      mesh: this.createChunkMesh(x, z)
    }
    this.chunks.set(`${x},${z}`, chunk)
    return chunk
  }
  
  createChunkMesh(chunkX, chunkZ) {
    const resolution = 32
    const size = this.chunkSize
    
    const geometry = new THREE.PlaneGeometry(size, size, resolution - 1, resolution - 1)
    const vertices = geometry.attributes.position.array
    const colors = new Float32Array(vertices.length)
    
    for (let i = 0; i < vertices.length; i += 3) {
      const localX = vertices[i]
      const localZ = vertices[i + 1]
      const worldX = chunkX * size + localX
      const worldZ = chunkZ * size + localZ
      
      // Set height
      vertices[i + 2] = this.getHeightAt(worldX, worldZ)
      
      // Set color based on biome
      const biome = this.getBiomeAt(worldX, worldZ)
      const color = new THREE.Color(biome.color)
      colors[i] = color.r
      colors[i + 1] = color.g
      colors[i + 2] = color.b
    }
    
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))
    geometry.rotateX(-Math.PI / 2)
    geometry.computeVertexNormals()
    
    const material = new THREE.MeshStandardMaterial({
      vertexColors: true,
      side: THREE.DoubleSide
    })
    
    const mesh = new THREE.Mesh(geometry, material)
    mesh.position.set(chunkX * size, 0, chunkZ * size)
    
    return mesh
  }
}

// Test state
let terrain = null
let testResults = []
let errorLog = []

// Color constants for visual testing
const COLORS = {
  TERRAIN_GRASS: 0x4a7c59,
  TERRAIN_DIRT: 0x8b4513,
  TERRAIN_STONE: 0x808080,
  TERRAIN_WATER: 0x4682b4,
  TERRAIN_SAND: 0xf4a460,
  TERRAIN_SNOW: 0xfffafa,
  TERRAIN_ICE: 0xb0e0e6,
  TERRAIN_LAVA: 0xff4500,
  TEST_POINT: 0xff0000,
  BIOME_CENTER: 0xff00ff,
  HEIGHT_SAMPLE: 0x00ff00
}

// Test points for terrain sampling
const TEST_POINTS = [
  { x: 0, z: 0, name: 'Center' },
  { x: 25, z: 25, name: 'NE Quadrant' },
  { x: -25, z: 25, name: 'NW Quadrant' },
  { x: 25, z: -25, name: 'SE Quadrant' },
  { x: -25, z: -25, name: 'SW Quadrant' },
  { x: 50, z: 0, name: 'East Edge' },
  { x: -50, z: 0, name: 'West Edge' },
  { x: 0, z: 50, name: 'North Edge' },
  { x: 0, z: -50, name: 'South Edge' }
]

// Add terrain meshes to the scene
async function addTerrainMeshesToScene() {
  console.log('[TerrainTest] Adding terrain meshes to scene...')
  
  // Force generation of some chunks to display
  const chunkSize = 50
  const chunkCount = 4 // Generate 4x4 chunks
  
  for (let x = -chunkCount/2; x < chunkCount/2; x++) {
    for (let z = -chunkCount/2; z < chunkCount/2; z++) {
      // Generate chunk (this will create the mesh)
      terrain.generateChunk(x, z)
      
      // Get the generated chunk
      const chunk = terrain.chunks.get(`${x},${z}`)
      
      if (chunk && chunk.mesh) {
        console.log(`[TerrainTest] Adding chunk mesh (${x}, ${z}) to scene`)
        app.add(chunk.mesh)
      } else {
        console.warn(`[TerrainTest] No mesh found for chunk (${x}, ${z})`)
      }
    }
  }
  
  console.log('[TerrainTest] Terrain meshes added to scene')
}

// Create overhead camera rig
function createOverheadCamera() {
  console.log('[TerrainTest] Setting up overhead camera...')
  
  // Create overhead camera
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
  camera.position.set(0, 100, 0)
  camera.lookAt(0, 0, 0)
  
  // Add camera to scene
  app.add(camera)
  
  // Set as main camera
  world.camera = camera
  
  console.log('[TerrainTest] Overhead camera setup complete')
}

// Create test character on terrain
function createTestCharacter() {
  console.log('[TerrainTest] Creating test character...')
  
  // Create character visual
  const geometry = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8)
  const material = new THREE.MeshBasicMaterial({ color: 0x0066ff })
  const character = new THREE.Mesh(geometry, material)
  
  // Position character at terrain height
  const characterX = 0
  const characterZ = 0
  const terrainHeight = terrain.getHeightAt(characterX, characterZ)
  character.position.set(characterX, terrainHeight + 1, characterZ)
  
  // Add character to scene
  app.add(character)
  
  console.log(`[TerrainTest] Test character created at (${characterX}, ${terrainHeight + 1}, ${characterZ})`)
  
  return character
}

// Initialize terrain generation test
async function initTerrainTest() {
  console.log('[TerrainTest] Initializing terrain generation test...')
  
  try {
    // Create terrain system
    terrain = new SimpleTerrain({
      seed: props.testSeed,
      worldSize: 200,
      chunkSize: 50,
      maxHeight: 25,
      waterLevel: 0
    })
    
    await terrain.init()
    console.log('[TerrainTest] Terrain initialized successfully')
    
    // CRITICAL: Add terrain meshes to the scene
    await addTerrainMeshesToScene()
    
    // Create overhead camera rig
    createOverheadCamera()
    
    // Create test character on terrain
    createTestCharacter()
    
    // Run terrain tests
    await runTerrainTests()
    
    // Create visual representations
    if (props.showVisualProxies) {
      createTerrainVisualization()
    }
    
    // Display results
    displayTestResults()
    
  } catch (error) {
    console.error('[TerrainTest] Test initialization failed:', error)
    errorLog.push(`Initialization failed: ${error.message}`)
  }
}

// Run comprehensive terrain tests
async function runTerrainTests() {
  console.log('[TerrainTest] Running terrain tests...')
  
  // Test 1: Height generation
  await testHeightGeneration()
  
  // Test 2: Biome distribution
  await testBiomeDistribution()
  
  // Test 3: Terrain types
  await testTerrainTypes()
  
  // Test 4: Walkability
  await testWalkability()
  
  // Test 5: Surface normals
  await testSurfaceNormals()
  
  // Test 6: Chunk generation
  await testChunkGeneration()
  
  // Test 7: Consistency with seed
  await testSeedConsistency()
}

// Test height generation
async function testHeightGeneration() {
  const testName = 'Height Generation'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    // Test height at all test points
    for (const point of TEST_POINTS) {
      const height = terrain.getHeightAt(point.x, point.z)
      
      // Validate height is a number
      if (typeof height !== 'number') {
        results.errors.push(`Height at ${point.name} (${point.x}, ${point.z}) is not a number: ${height}`)
        results.passed = false
      }
      
      // Validate height is within reasonable bounds
      if (height < -50 || height > 50) {
        results.warnings.push(`Height at ${point.name} seems extreme: ${height}`)
      }
      
      // Check for NaN
      if (isNaN(height)) {
        results.errors.push(`Height at ${point.name} is NaN`)
        results.passed = false
      }
      
      console.log(`[TerrainTest] Height at ${point.name}: ${height}`)
    }
    
    // Test height interpolation consistency
    const h1 = terrain.getHeightAt(0, 0)
    const h2 = terrain.getHeightAt(0.1, 0)
    const h3 = terrain.getHeightAt(0, 0.1)
    
    if (Math.abs(h1 - h2) > 10 || Math.abs(h1 - h3) > 10) {
      results.warnings.push('Height interpolation may be too abrupt')
    }
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test biome distribution
async function testBiomeDistribution() {
  const testName = 'Biome Distribution'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    const biomePoints = terrain.getBiomePoints()
    
    // Check biome count
    if (biomePoints.length !== 4) {
      results.errors.push(`Expected 4 biomes, got ${biomePoints.length}`)
      results.passed = false
    }
    
    // Test biome assignment at test points
    const biomeMap = new Map()
    
    for (const point of TEST_POINTS) {
      const biome = terrain.getBiomeAt(point.x, point.z)
      
      if (!biome) {
        results.errors.push(`No biome found at ${point.name}`)
        results.passed = false
        continue
      }
      
      biomeMap.set(biome.id, (biomeMap.get(biome.id) || 0) + 1)
      console.log(`[TerrainTest] Biome at ${point.name}: ${biome.name}`)
    }
    
    // Check biome diversity
    if (biomeMap.size < 2) {
      results.warnings.push(`Low biome diversity: only ${biomeMap.size} unique biomes`)
    }
    
    results.data.biomeDistribution = Object.fromEntries(biomeMap)
    results.data.biomeCount = biomePoints.length
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test terrain types
async function testTerrainTypes() {
  const testName = 'Terrain Types'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    const terrainTypeMap = new Map()
    
    for (const point of TEST_POINTS) {
      const terrainType = terrain.getTypeAt(point.x, point.z)
      
      if (!terrainType) {
        results.errors.push(`No terrain type at ${point.name}`)
        results.passed = false
        continue
      }
      
      terrainTypeMap.set(terrainType, (terrainTypeMap.get(terrainType) || 0) + 1)
      console.log(`[TerrainTest] Terrain type at ${point.name}: ${terrainType}`)
    }
    
    results.data.terrainTypes = Object.fromEntries(terrainTypeMap)
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test walkability
async function testWalkability() {
  const testName = 'Walkability'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    let walkableCount = 0
    let nonWalkableCount = 0
    
    for (const point of TEST_POINTS) {
      const walkable = terrain.isWalkable(point.x, point.z)
      
      if (typeof walkable !== 'boolean') {
        results.errors.push(`Walkability at ${point.name} is not boolean: ${walkable}`)
        results.passed = false
        continue
      }
      
      if (walkable) {
        walkableCount++
      } else {
        nonWalkableCount++
      }
      
      console.log(`[TerrainTest] Walkable at ${point.name}: ${walkable}`)
    }
    
    results.data.walkableCount = walkableCount
    results.data.nonWalkableCount = nonWalkableCount
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test surface normals
async function testSurfaceNormals() {
  const testName = 'Surface Normals'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    for (const point of TEST_POINTS) {
      const normal = terrain.getNormalAt(point.x, point.z)
      
      if (!normal || !normal.isVector3) {
        results.errors.push(`Invalid normal at ${point.name}: ${normal}`)
        results.passed = false
        continue
      }
      
      // Check if normal is normalized
      const length = normal.length()
      if (Math.abs(length - 1) > 0.1) {
        results.warnings.push(`Normal at ${point.name} not normalized: length = ${length}`)
      }
      
      console.log(`[TerrainTest] Normal at ${point.name}: (${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)})`)
    }
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test chunk generation
async function testChunkGeneration() {
  const testName = 'Chunk Generation'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    // Force chunk generation at various locations
    const chunkPoints = [
      { x: 0, z: 0 },
      { x: 75, z: 75 },
      { x: -75, z: 75 },
      { x: 75, z: -75 },
      { x: -75, z: -75 }
    ]
    
    for (const point of chunkPoints) {
      // Getting height should trigger chunk generation
      const height = terrain.getHeightAt(point.x, point.z)
      
      if (typeof height !== 'number') {
        results.errors.push(`Chunk generation failed at (${point.x}, ${point.z})`)
        results.passed = false
      }
    }
    
    // Check debug info
    const debugInfo = terrain.getDebugInfo()
    if (debugInfo.chunkCount === 0) {
      results.errors.push('No chunks were generated')
      results.passed = false
    }
    
    results.data.chunkCount = debugInfo.chunkCount
    results.data.totalVertices = debugInfo.totalVertices
    
    console.log(`[TerrainTest] Generated ${debugInfo.chunkCount} chunks with ${debugInfo.totalVertices} vertices`)
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Test seed consistency
async function testSeedConsistency() {
  const testName = 'Seed Consistency'
  console.log(`[TerrainTest] Running ${testName}...`)
  
  try {
    const results = {
      testName,
      passed: true,
      errors: [],
      warnings: [],
      data: {}
    }
    
    // Create second terrain with same seed
    const terrain2 = new ProceduralTerrain(world, {
      seed: props.testSeed,
      biomeCount: 4,
      worldSize: 200,
      chunkSize: 50,
      chunkResolution: 32,
      maxHeight: 25,
      waterLevel: 0
    })
    
    await terrain2.init()
    
    // Compare heights at test points
    for (const point of TEST_POINTS) {
      const height1 = terrain.getHeightAt(point.x, point.z)
      const height2 = terrain2.getHeightAt(point.x, point.z)
      
      if (Math.abs(height1 - height2) > 0.001) {
        results.errors.push(`Height inconsistency at ${point.name}: ${height1} vs ${height2}`)
        results.passed = false
      }
    }
    
    testResults.push(results)
    console.log(`[TerrainTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[TerrainTest] ${testName} failed:`, error)
    testResults.push({
      testName,
      passed: false,
      errors: [`Test execution failed: ${error.message}`],
      warnings: [],
      data: {}
    })
  }
}

// Create terrain visualization
function createTerrainVisualization() {
  console.log('[TerrainTest] Creating terrain visualization...')
  
  // Create terrain mesh
  const terrainGroup = new THREE.Group()
  
  // Create height samples
  const sampleCount = 20
  const sampleSize = 100
  
  for (let x = 0; x < sampleCount; x++) {
    for (let z = 0; z < sampleCount; z++) {
      const worldX = (x / sampleCount - 0.5) * sampleSize
      const worldZ = (z / sampleCount - 0.5) * sampleSize
      
      const height = terrain.getHeightAt(worldX, worldZ)
      const terrainType = terrain.getTypeAt(worldX, worldZ)
      
      // Create colored cube based on terrain type
      let color = COLORS.TERRAIN_GRASS
      switch (terrainType) {
        case 'grass': color = COLORS.TERRAIN_GRASS; break
        case 'dirt': color = COLORS.TERRAIN_DIRT; break
        case 'stone': color = COLORS.TERRAIN_STONE; break
        case 'water': color = COLORS.TERRAIN_WATER; break
        case 'sand': color = COLORS.TERRAIN_SAND; break
        case 'snow': color = COLORS.TERRAIN_SNOW; break
        case 'ice': color = COLORS.TERRAIN_ICE; break
        case 'lava': color = COLORS.TERRAIN_LAVA; break
      }
      
      const geometry = new THREE.BoxGeometry(2, 1, 2)
      const material = new THREE.MeshBasicMaterial({ color })
      const cube = new THREE.Mesh(geometry, material)
      
      cube.position.set(worldX, height, worldZ)
      terrainGroup.add(cube)
    }
  }
  
  app.add(terrainGroup)
  
  // Create test point markers
  for (const point of TEST_POINTS) {
    const height = terrain.getHeightAt(point.x, point.z)
    
    const geometry = new THREE.SphereGeometry(1, 8, 8)
    const material = new THREE.MeshBasicMaterial({ color: COLORS.TEST_POINT })
    const sphere = new THREE.Mesh(geometry, material)
    
    sphere.position.set(point.x, height + 2, point.z)
    app.add(sphere)
  }
  
  // Create biome center markers
  const biomePoints = terrain.getBiomePoints()
  for (const point of biomePoints) {
    const geometry = new THREE.ConeGeometry(2, 4, 8)
    const material = new THREE.MeshBasicMaterial({ color: COLORS.BIOME_CENTER })
    const cone = new THREE.Mesh(geometry, material)
    
    cone.position.set(point.x, 10, point.z)
    app.add(cone)
  }
}

// Display test results
function displayTestResults() {
  console.log('\n=== TERRAIN GENERATION TEST RESULTS ===')
  
  const totalTests = testResults.length
  const passedTests = testResults.filter(r => r.passed).length
  const failedTests = totalTests - passedTests
  
  console.log(`Total Tests: ${totalTests}`)
  console.log(`Passed: ${passedTests}`)
  console.log(`Failed: ${failedTests}`)
  console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`)
  
  for (const result of testResults) {
    console.log(`\n${result.testName}: ${result.passed ? 'PASS' : 'FAIL'}`)
    
    if (result.errors.length > 0) {
      console.log('  Errors:')
      for (const error of result.errors) {
        console.log(`    - ${error}`)
      }
    }
    
    if (result.warnings.length > 0) {
      console.log('  Warnings:')
      for (const warning of result.warnings) {
        console.log(`    - ${warning}`)
      }
    }
    
    if (Object.keys(result.data).length > 0) {
      console.log('  Data:', result.data)
    }
  }
  
  if (errorLog.length > 0) {
    console.log('\n=== ERROR LOG ===')
    for (const error of errorLog) {
      console.log(error)
    }
  }
  
  console.log('\n=== TEST COMPLETE ===')
}

// Setup lighting
function setupLighting() {
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6)
  app.add(ambientLight)
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
  directionalLight.position.set(50, 50, 50)
  app.add(directionalLight)
}

// Initialize when app starts
app.on('start', async () => {
  console.log('[TerrainTest] Starting terrain generation test...')
  
  setupLighting()
  await initTerrainTest()
  
  console.log('[TerrainTest] Terrain generation test complete!')
})

// Cleanup
app.on('destroy', () => {
  console.log('[TerrainTest] Cleaning up...')
  
  if (terrain) {
    terrain.clearChunks()
  }
})
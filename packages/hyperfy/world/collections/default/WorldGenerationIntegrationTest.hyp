// Test World: World Generation Integration
// This test world tests the complete world generation pipeline
// including terrain, biomes, towns, spawners, and all integrated systems

app.configure([
  {
    key: 'testSeed',
    type: 'number',
    label: 'Test Seed',
    initial: 98765,
    min: 1,
    max: 999999,
    hint: 'Seed for world generation'
  },
  {
    key: 'worldSize',
    type: 'select',
    label: 'World Size',
    initial: 'medium',
    options: ['small', 'medium', 'large'],
    hint: 'Size of the generated world'
  },
  {
    key: 'showDebugInfo',
    type: 'toggle',
    label: 'Show Debug Info',
    initial: true,
    hint: 'Show debug visualization and info'
  }
])

// Import required systems
import { ProceduralTerrain } from '../../core/systems/ProceduralTerrain.js'
import { ProceduralWorldGenerator } from '../../core/systems/ProceduralWorldGenerator.js'

// Test state
let worldGenerator = null
let terrain = null
let testResults = []
let errorLog = []
let worldConfig = null
let testStartTime = 0

// Color constants for visual testing
const COLORS = {
  TERRAIN: 0x654321,       // Dark Brown
  BIOME_CENTER: 0xff00ff,  // Magenta
  TOWN: 0xffff00,          // Yellow
  SPAWNER_GOBLIN: 0x00ff00, // Green
  SPAWNER_GUARD: 0xff0000,  // Red
  SPAWNER_RESOURCE: 0x8b4513, // Brown
  WATER: 0x4682b4,         // Steel Blue
  SAFE_ZONE: 0x00ffff,     // Cyan
  TEST_SUCCESS: 0x00ff00,  // Green
  TEST_FAILURE: 0xff0000   // Red
}

// World generation test parameters
const WORLD_SIZES = {
  small: 200,
  medium: 500,
  large: 1000
}

// Initialize integration test
async function initIntegrationTest() {
  console.log('[IntegrationTest] Initializing world generation integration test...')
  
  try {
    testStartTime = Date.now()
    
    // Create world generator
    worldGenerator = new ProceduralWorldGenerator(world)
    console.log('[IntegrationTest] World generator created')
    
    // Generate world design
    await generateWorldDesign()
    
    // Initialize world systems
    await initializeWorldSystems()
    
    // Run integration tests
    await runIntegrationTests()
    
    // Create debug visualization
    if (props.showDebugInfo) {
      createDebugVisualization()
    }
    
    // Display results
    displayTestResults()
    
  } catch (error) {
    console.error('[IntegrationTest] Test initialization failed:', error)
    errorLog.push(`Initialization failed: ${error.message}`)
  }
}

// Generate world design
async function generateWorldDesign() {
  console.log('[IntegrationTest] Generating world design...')
  
  try {
    const worldPrompt = {
      theme: 'fantasy',
      difficulty: 'medium',
      size: props.worldSize,
      biomes: [],
      features: ['towns', 'resources', 'mobs', 'safe_zones'],
      lore: 'Integration test fantasy world with diverse biomes and balanced gameplay'
    }
    
    worldConfig = await worldGenerator.generateWorldDesign(worldPrompt)
    
    if (!worldConfig) {
      throw new Error('World config generation failed')
    }
    
    console.log('[IntegrationTest] World design generated successfully')
    console.log(`  - World Size: ${worldConfig.worldSize}`)
    console.log(`  - Biome Count: ${worldConfig.biomes.length}`)
    console.log(`  - Town Count: ${worldConfig.towns.length}`)
    console.log(`  - Spawner Count: ${worldConfig.spawners.length}`)
    
  } catch (error) {
    console.error('[IntegrationTest] World design generation failed:', error)
    throw error
  }
}

// Initialize world systems
async function initializeWorldSystems() {
  console.log('[IntegrationTest] Initializing world systems...')
  
  try {
    // Initialize the world
    await worldGenerator.initializeWorld(worldConfig)
    
    // Get terrain reference
    terrain = worldGenerator.getTerrain()
    if (!terrain) {
      throw new Error('Terrain system not initialized')
    }
    
    console.log('[IntegrationTest] World systems initialized successfully')
    
  } catch (error) {
    console.error('[IntegrationTest] World system initialization failed:', error)
    throw error
  }
}

// Run integration tests
async function runIntegrationTests() {
  console.log('[IntegrationTest] Running integration tests...')
  
  // Test 1: World configuration validation
  await testWorldConfiguration()
  
  // Test 2: Terrain system integration
  await testTerrainIntegration()
  
  // Test 3: Biome system integration
  await testBiomeIntegration()
  
  // Test 4: Town placement integration
  await testTownIntegration()
  
  // Test 5: Spawner system integration
  await testSpawnerIntegration()
  
  // Test 6: Cross-system validation
  await testCrossSystemValidation()
  
  // Test 7: Performance validation
  await testPerformanceValidation()
}

// Test world configuration
async function testWorldConfiguration() {
  const testName = 'World Configuration'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    // Validate world config structure
    if (!worldConfig) {
      results.errors.push('World config is null or undefined')
      results.passed = false
    } else {
      // Check required properties
      const required = ['worldSize', 'biomes', 'towns', 'spawners', 'seed']
      for (const prop of required) {
        if (!(prop in worldConfig)) {
          results.errors.push(`Missing required property: ${prop}`)
          results.passed = false
        }
      }
      
      // Validate world size matches request
      const expectedSize = WORLD_SIZES[props.worldSize]
      if (worldConfig.worldSize !== expectedSize) {
        results.errors.push(`World size mismatch: expected ${expectedSize}, got ${worldConfig.worldSize}`)
        results.passed = false
      }
      
      // Validate biome count is reasonable
      if (worldConfig.biomes.length < 3 || worldConfig.biomes.length > 8) {
        results.warnings.push(`Unusual biome count: ${worldConfig.biomes.length}`)
      }
      
      // Validate town count is reasonable
      if (worldConfig.towns.length === 0) {
        results.errors.push('No towns generated')
        results.passed = false
      } else if (worldConfig.towns.length > 10) {
        results.warnings.push(`High town count: ${worldConfig.towns.length}`)
      }
      
      // Validate spawner count
      if (worldConfig.spawners.length === 0) {
        results.errors.push('No spawners generated')
        results.passed = false
      }
    }
    
    results.data = {
      worldSize: worldConfig?.worldSize,
      biomeCount: worldConfig?.biomes?.length,
      townCount: worldConfig?.towns?.length,
      spawnerCount: worldConfig?.spawners?.length
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test terrain integration
async function testTerrainIntegration() {
  const testName = 'Terrain Integration'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    if (!terrain) {
      results.errors.push('Terrain system not available')
      results.passed = false
      return
    }
    
    // Test terrain queries at various points
    const testPoints = [
      { x: 0, z: 0 },
      { x: worldConfig.worldSize / 4, z: worldConfig.worldSize / 4 },
      { x: -worldConfig.worldSize / 4, z: worldConfig.worldSize / 4 },
      { x: worldConfig.worldSize / 4, z: -worldConfig.worldSize / 4 },
      { x: -worldConfig.worldSize / 4, z: -worldConfig.worldSize / 4 }
    ]
    
    let validHeights = 0
    let validBiomes = 0
    let validWalkability = 0
    
    for (const point of testPoints) {
      // Test height
      const height = terrain.getHeightAt(point.x, point.z)
      if (typeof height === 'number' && !isNaN(height)) {
        validHeights++
      } else {
        results.errors.push(`Invalid height at (${point.x}, ${point.z}): ${height}`)
        results.passed = false
      }
      
      // Test biome
      const biome = terrain.getBiomeAt(point.x, point.z)
      if (biome && biome.id) {
        validBiomes++
      } else {
        results.errors.push(`Invalid biome at (${point.x}, ${point.z})`)
        results.passed = false
      }
      
      // Test walkability
      const walkable = terrain.isWalkable(point.x, point.z)
      if (typeof walkable === 'boolean') {
        validWalkability++
      } else {
        results.errors.push(`Invalid walkability at (${point.x}, ${point.z}): ${walkable}`)
        results.passed = false
      }
    }
    
    results.data = {
      pointsTested: testPoints.length,
      validHeights,
      validBiomes,
      validWalkability
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test biome integration
async function testBiomeIntegration() {
  const testName = 'Biome Integration'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    const biomePoints = terrain.getBiomePoints()
    
    // Validate biome points match config
    if (biomePoints.length !== worldConfig.biomes.length) {
      results.errors.push(`Biome count mismatch: config has ${worldConfig.biomes.length}, terrain has ${biomePoints.length}`)
      results.passed = false
    }
    
    // Test biome coverage
    const sampleCount = 50
    const biomeUsage = new Map()
    
    for (let i = 0; i < sampleCount; i++) {
      const x = (Math.random() - 0.5) * worldConfig.worldSize
      const z = (Math.random() - 0.5) * worldConfig.worldSize
      
      const biome = terrain.getBiomeAt(x, z)
      if (biome) {
        biomeUsage.set(biome.id, (biomeUsage.get(biome.id) || 0) + 1)
      }
    }
    
    // Check biome diversity
    const uniqueBiomes = biomeUsage.size
    if (uniqueBiomes < Math.max(2, worldConfig.biomes.length - 1)) {
      results.warnings.push(`Low biome diversity: only ${uniqueBiomes} unique biomes found in sampling`)
    }
    
    // Validate biome properties
    for (const biome of worldConfig.biomes) {
      if (!biome.name || !biome.primaryType) {
        results.errors.push(`Biome missing required properties: ${JSON.stringify(biome)}`)
        results.passed = false
      }
    }
    
    results.data = {
      configBiomes: worldConfig.biomes.length,
      terrainBiomes: biomePoints.length,
      sampledBiomes: uniqueBiomes,
      biomeUsage: Object.fromEntries(biomeUsage)
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test town integration
async function testTownIntegration() {
  const testName = 'Town Integration'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    const towns = worldConfig.towns
    let validTowns = 0
    
    for (const town of towns) {
      // Check town structure
      if (!town.position || typeof town.position.x !== 'number' || typeof town.position.z !== 'number') {
        results.errors.push(`Town missing valid position: ${JSON.stringify(town)}`)
        results.passed = false
        continue
      }
      
      // Check if town is in walkable area
      const walkable = terrain.isWalkable(town.position.x, town.position.z)
      if (!walkable) {
        results.errors.push(`Town at (${town.position.x}, ${town.position.z}) is not walkable`)
        results.passed = false
      }
      
      // Check if town is in reasonable biome
      const biome = terrain.getBiomeAt(town.position.x, town.position.z)
      if (biome && (biome.primaryType === 'water' || biome.primaryType === 'lava')) {
        results.warnings.push(`Town at (${town.position.x}, ${town.position.z}) is in ${biome.primaryType} biome`)
      }
      
      // Check town properties
      if (!town.name || !town.type) {
        results.errors.push(`Town missing name or type: ${JSON.stringify(town)}`)
        results.passed = false
      } else {
        validTowns++
      }
    }
    
    results.data = {
      totalTowns: towns.length,
      validTowns
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test spawner integration
async function testSpawnerIntegration() {
  const testName = 'Spawner Integration'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    const spawners = worldConfig.spawners
    let validSpawners = 0
    const spawnerTypes = new Map()
    
    for (const spawner of spawners) {
      // Check spawner structure
      if (!spawner.position || !spawner.entityDefinitions) {
        results.errors.push(`Spawner missing required properties: ${JSON.stringify(spawner)}`)
        results.passed = false
        continue
      }
      
      // Check spawner position is valid
      const walkable = terrain.isWalkable(spawner.position.x, spawner.position.z)
      if (!walkable) {
        results.warnings.push(`Spawner at (${spawner.position.x}, ${spawner.position.z}) is not in walkable area`)
      }
      
      // Check entity definitions
      if (spawner.entityDefinitions.length === 0) {
        results.errors.push(`Spawner has no entity definitions: ${JSON.stringify(spawner)}`)
        results.passed = false
      } else {
        for (const entity of spawner.entityDefinitions) {
          if (!entity.type) {
            results.errors.push(`Entity definition missing type: ${JSON.stringify(entity)}`)
            results.passed = false
          } else {
            spawnerTypes.set(entity.type, (spawnerTypes.get(entity.type) || 0) + 1)
          }
        }
        validSpawners++
      }
    }
    
    // Check spawner diversity
    if (spawnerTypes.size < 2) {
      results.warnings.push(`Low spawner diversity: only ${spawnerTypes.size} entity types`)
    }
    
    results.data = {
      totalSpawners: spawners.length,
      validSpawners,
      entityTypes: spawnerTypes.size,
      spawnerDistribution: Object.fromEntries(spawnerTypes)
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test cross-system validation
async function testCrossSystemValidation() {
  const testName = 'Cross-System Validation'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    // Test that towns are not in water
    let townsInWater = 0
    for (const town of worldConfig.towns) {
      const biome = terrain.getBiomeAt(town.position.x, town.position.z)
      if (biome && biome.primaryType === 'water') {
        townsInWater++
      }
    }
    
    if (townsInWater > 0) {
      results.errors.push(`${townsInWater} towns are placed in water biomes`)
      results.passed = false
    }
    
    // Test that spawners are distributed across biomes
    const spawnerBiomes = new Map()
    for (const spawner of worldConfig.spawners) {
      const biome = terrain.getBiomeAt(spawner.position.x, spawner.position.z)
      if (biome) {
        spawnerBiomes.set(biome.id, (spawnerBiomes.get(biome.id) || 0) + 1)
      }
    }
    
    if (spawnerBiomes.size < 2) {
      results.warnings.push(`Spawners concentrated in ${spawnerBiomes.size} biomes`)
    }
    
    // Test town spacing
    const towns = worldConfig.towns
    let tooClose = 0
    for (let i = 0; i < towns.length; i++) {
      for (let j = i + 1; j < towns.length; j++) {
        const dist = Math.sqrt(
          Math.pow(towns[i].position.x - towns[j].position.x, 2) +
          Math.pow(towns[i].position.z - towns[j].position.z, 2)
        )
        if (dist < 50) { // Minimum spacing
          tooClose++
        }
      }
    }
    
    if (tooClose > 0) {
      results.warnings.push(`${tooClose} town pairs are too close together`)
    }
    
    results.data = {
      townsInWater,
      spawnerBiomeDiversity: spawnerBiomes.size,
      closelySpacedTowns: tooClose
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Test performance validation
async function testPerformanceValidation() {
  const testName = 'Performance Validation'
  console.log(`[IntegrationTest] Running ${testName}...`)
  
  try {
    const results = { testName, passed: true, errors: [], warnings: [], data: {} }
    
    // Test terrain query performance
    const queryCount = 1000
    const startTime = performance.now()
    
    for (let i = 0; i < queryCount; i++) {
      const x = (Math.random() - 0.5) * worldConfig.worldSize
      const z = (Math.random() - 0.5) * worldConfig.worldSize
      
      terrain.getHeightAt(x, z)
      terrain.getBiomeAt(x, z)
      terrain.isWalkable(x, z)
    }
    
    const queryTime = performance.now() - startTime
    const avgQueryTime = queryTime / queryCount
    
    if (avgQueryTime > 2.0) {
      results.warnings.push(`Slow terrain queries: ${avgQueryTime.toFixed(3)}ms average`)
    }
    
    // Test world stats
    const worldStats = worldGenerator.getWorldStats()
    if (!worldStats) {
      results.errors.push('World stats not available')
      results.passed = false
    }
    
    // Test total generation time
    const totalTime = Date.now() - testStartTime
    if (totalTime > 30000) { // 30 seconds
      results.warnings.push(`Slow world generation: ${totalTime}ms total`)
    }
    
    results.data = {
      queryCount,
      avgQueryTime,
      totalGenerationTime: totalTime,
      worldStats: worldStats || {}
    }
    
    testResults.push(results)
    console.log(`[IntegrationTest] ${testName} ${results.passed ? 'PASSED' : 'FAILED'}`)
    
  } catch (error) {
    console.error(`[IntegrationTest] ${testName} failed:`, error)
    testResults.push({
      testName, passed: false, errors: [`Test execution failed: ${error.message}`],
      warnings: [], data: {}
    })
  }
}

// Create debug visualization
function createDebugVisualization() {
  console.log('[IntegrationTest] Creating debug visualization...')
  
  if (!worldConfig || !terrain) return
  
  // Create biome center markers
  const biomePoints = terrain.getBiomePoints()
  for (const point of biomePoints) {
    const geometry = new THREE.ConeGeometry(3, 6, 8)
    const material = new THREE.MeshBasicMaterial({ color: COLORS.BIOME_CENTER })
    const marker = new THREE.Mesh(geometry, material)
    
    marker.position.set(point.x, 15, point.z)
    app.add(marker)
  }
  
  // Create town markers
  for (const town of worldConfig.towns) {
    const geometry = new THREE.BoxGeometry(4, 4, 4)
    const material = new THREE.MeshBasicMaterial({ color: COLORS.TOWN })
    const marker = new THREE.Mesh(geometry, material)
    
    const height = terrain.getHeightAt(town.position.x, town.position.z)
    marker.position.set(town.position.x, height + 2, town.position.z)
    app.add(marker)
  }
  
  // Create spawner markers
  for (const spawner of worldConfig.spawners) {
    let color = COLORS.SPAWNER_GOBLIN
    if (spawner.entityDefinitions[0]?.type?.includes('guard')) {
      color = COLORS.SPAWNER_GUARD
    } else if (spawner.entityDefinitions[0]?.type?.includes('resource')) {
      color = COLORS.SPAWNER_RESOURCE
    }
    
    const geometry = new THREE.SphereGeometry(1.5, 8, 8)
    const material = new THREE.MeshBasicMaterial({ color })
    const marker = new THREE.Mesh(geometry, material)
    
    const height = terrain.getHeightAt(spawner.position.x, spawner.position.z)
    marker.position.set(spawner.position.x, height + 1.5, spawner.position.z)
    app.add(marker)
  }
}

// Display test results
function displayTestResults() {
  console.log('\n=== WORLD GENERATION INTEGRATION TEST RESULTS ===')
  
  const totalTests = testResults.length
  const passedTests = testResults.filter(r => r.passed).length
  const failedTests = totalTests - passedTests
  const testDuration = (Date.now() - testStartTime) / 1000
  
  console.log(`Total Tests: ${totalTests}`)
  console.log(`Passed: ${passedTests}`)
  console.log(`Failed: ${failedTests}`)
  console.log(`Test Duration: ${testDuration.toFixed(1)}s`)
  console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`)
  
  for (const result of testResults) {
    console.log(`\n${result.testName}: ${result.passed ? 'PASS' : 'FAIL'}`)
    
    if (result.errors.length > 0) {
      console.log('  Errors:')
      for (const error of result.errors) {
        console.log(`    - ${error}`)
      }
    }
    
    if (result.warnings.length > 0) {
      console.log('  Warnings:')
      for (const warning of result.warnings) {
        console.log(`    - ${warning}`)
      }
    }
    
    if (Object.keys(result.data).length > 0) {
      console.log('  Data:', result.data)
    }
  }
  
  if (errorLog.length > 0) {
    console.log('\n=== ERROR LOG ===')
    for (const error of errorLog) {
      console.log(error)
    }
  }
  
  console.log('\n=== INTEGRATION TEST COMPLETE ===')
}

// Setup lighting
function setupLighting() {
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6)
  app.add(ambientLight)
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
  directionalLight.position.set(100, 100, 100)
  app.add(directionalLight)
}

// Initialize when app starts
app.on('start', async () => {
  console.log('[IntegrationTest] Starting world generation integration test...')
  
  setupLighting()
  await initIntegrationTest()
  
  console.log('[IntegrationTest] World generation integration test complete!')
})

// Cleanup
app.on('destroy', () => {
  console.log('[IntegrationTest] Cleaning up...')
  
  if (terrain) {
    terrain.clearChunks()
  }
  
  if (worldGenerator) {
    // Clean up world generator resources
  }
})